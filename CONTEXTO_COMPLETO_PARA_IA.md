# üîã SISTEMA INVERSOR H√çBRIDO INTELIGENTE - CONTEXTO COMPLETO

**Para: Nueva IA que va a ayudar con este proyecto**  
**Fecha: Octubre 2025**  
**Estado: 95% funcional - Solo faltan 2 bugs cr√≠ticos**

---

## üìä QU√â ES ESTE PROYECTO

Sistema COMPLETO de gesti√≥n energ√©tica h√≠brida (Solar + E√≥lico + Bater√≠a) con:
- **IA Predictiva** (Random Forest) usando datos meteorol√≥gicos reales
- **ESP32** con firmware complejo (FreeRTOS, sensores, rel√©s, HTTP, JSON)
- **Backend FastAPI** (Puerto 11113) con ML, base de datos, APIs
- **Frontend React** (Puerto 11112) con dashboard, gr√°ficos, control en tiempo real
- **Protecci√≥n inteligente** contra embalamiento e√≥lico
- **Estrategia autom√°tica** de priorizaci√≥n de fuentes
- **4 Rel√©s** controlables remotamente (Solar, E√≥lica, Red, Carga)
- **6 ADCs** (4 voltajes + LDR + Anem√≥metro)

---

## üö® PROBLEMAS ACTUALES (LO QUE HAY QUE ARREGLAR)

### **PROBLEMA 1: GET -7 (Intermitente)**
**S√≠ntoma:**
```
[12] POST:200 GET:-7 | R:---C | D34:0.000V D36:0.000V D35:0.000V D39:0.000V
```

**Causa ra√≠z:** 
- Timeout de 15s no es suficiente para WiFi lento del usuario
- ESP pierde comandos cuando GET -7 ocurre

**Impacto:**
- Comandos se encolan en backend pero ESP no los recibe
- De 6 comandos enviados, solo 1 llega

**¬øQu√© NO funciona como workaround:**
- ‚ùå Aumentar timeout a 15s (ya probado, sigue fallando)
- ‚ùå Reintentos autom√°ticos (no implementado)
- ‚ùå Cola persistente (se borra en cada GET)

**Soluci√≥n ideal:**
- WebSocket bidireccional ESP ‚Üî Backend
- O sistema de ACK: ESP confirma comando ejecutado en siguiente telemetr√≠a


### **PROBLEMA 2: Sin confirmaci√≥n real de comandos**
**S√≠ntoma:**
Usuario env√≠a comando ‚Üí Backend dice "success" ‚Üí No hay forma de saber si ESP lo ejecut√≥

**Qu√© pasa ahora:**
```bash
$ send_esp32_command.bat eolica on
{"status":"success",...}  # ‚Üê Backend dice OK, pero ESP quiz√°s nunca lo recibi√≥
```

**Soluci√≥n ideal:**
- ESP incluye en telemetr√≠a: `{"last_command_executed": "eolica on", "timestamp": "..."}`
- Backend trackea: comandos_enviados vs comandos_ejecutados
- Script espera confirmaci√≥n antes de decir "Listo"

---

## üèóÔ∏è ARQUITECTURA ACTUAL (LO QUE YA FUNCIONA)

### **Estructura de carpetas:**
```
X:\PREDICCION DE CLIMA\
‚îú‚îÄ‚îÄ backend/                    # FastAPI (Puerto 11113)
‚îÇ   ‚îú‚îÄ‚îÄ main.py                # Endpoints, ML, l√≥gica principal
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt       # fastapi, uvicorn, scikit-learn, etc
‚îÇ   ‚îî‚îÄ‚îÄ configuracion_usuario.json
‚îú‚îÄ‚îÄ frontend/                   # React (Puerto 11112)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ESP32Control.jsx    # Control rel√©s + ADCs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ESP32Status.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ api.js         # axios, baseURL=11113
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ firmware_arduino_ide_2/
‚îÇ   ‚îî‚îÄ‚îÄ inversor_hibrido/
‚îÇ       ‚îú‚îÄ‚îÄ inversor_hibrido.ino    # Main loop
‚îÇ       ‚îú‚îÄ‚îÄ config.h                 # WiFi, SERVER_URL, pines
‚îÇ       ‚îú‚îÄ‚îÄ sensors.h                # Lectura ADCs
‚îÇ       ‚îú‚îÄ‚îÄ relays.h                 # Control rel√©s
‚îÇ       ‚îî‚îÄ‚îÄ http_client.h            # POST/GET, JSON, comandos
‚îú‚îÄ‚îÄ send_esp32_command.bat     # Script para enviar comandos
‚îú‚îÄ‚îÄ test_reles.bat             # Men√∫ interactivo rel√©s
‚îú‚îÄ‚îÄ INICIAR_SISTEMA.bat        # Inicia backend + frontend
‚îî‚îÄ‚îÄ üìò SISTEMA INVERSOR H√çBRIDO - MANUAL T√âCNICO COMPLETO.pdf (x4)
```

### **Puertos y URLs:**
- Backend: `http://190.211.201.217:11113` o `http://localhost:11113`
- Frontend: `http://localhost:11112`
- ESP32 IP: Din√°mica (DHCP), ej: `192.168.1.105`

### **Endpoints Backend (los que importan):**
```
POST /api/esp32/telemetry         ‚Üê ESP env√≠a datos cada 1s
GET  /api/esp32/commands/{id}     ‚Üê ESP consulta comandos cada 1s
POST /api/esp32/command/{id}      ‚Üê Frontend/script env√≠a comando
GET  /api/esp32/estado/{id}       ‚Üê Frontend consulta estado ESP
```

### **Flujo de comandos (actual):**
```
1. Usuario presiona bot√≥n frontend o ejecuta .bat
2. POST /api/esp32/command ‚Üí Backend encola comando
3. ESP hace GET /api/esp32/commands (polling cada 1s)
4. Backend retorna lista de comandos y vac√≠a cola
5. ESP ejecuta comando, muestra en Serial
6. (NO HAY ACK - este es el problema)
```

---

## üíª FIRMWARE ESP32 - DETALLES T√âCNICOS

### **Hardware:**
- Placa: ESP32 Dev Module
- Serial: 115200 baud
- WiFi: 2.4GHz

### **Pines configurados:**

#### ADC (0-3.3V, 12-bit):
- GPIO34 ‚Üí Bater√≠a (v_bat_v)
- GPIO35 ‚Üí E√≥lica DC filtrado (v_wind_v_dc) con filtro Biquad IIR
- GPIO36 ‚Üí Solar (v_solar_v)
- GPIO39 ‚Üí Carga (v_load_v)
- GPIO27 ‚Üí LDR (irradiancia)
- GPIO14 ‚Üí Anem√≥metro (pulsos)

#### Rel√©s (OUTPUT, activo HIGH):
- GPIO26 ‚Üí Panel Solar
- GPIO25 ‚Üí E√≥lica
- GPIO32 ‚Üí Red Backup
- GPIO33 ‚Üí Carga
- GPIO23 ‚Üí Freno embalamiento

### **Archivos del firmware:**

**config.h** - Configuraci√≥n:
```cpp
#define WIFI_SSID "..."
#define WIFI_PASSWORD "..."
#define SERVER_URL "http://190.211.201.217:11113"
#define DEVICE_ID "ESP32_INVERSOR_001"

#define PIN_RELE_SOLAR  26
#define PIN_RELE_EOLICA 25
#define PIN_RELE_RED    32
#define PIN_RELE_CARGA  33
// ... etc
```

**http_client.h** - Comunicaci√≥n:
- `sendStage1Telemetry()` - POST cada 1s con JSON {seq, v_bat_v, ...}
- `checkStage1Commands()` - GET cada 1s, parsea JSON, ejecuta comandos
- Timeout actual: 15000ms (15s)
- Serial output: `[seq] POST:code GET:code | R:xxxx | D34:x.xxx...`

**sensors.h** - Sensores:
- Filtro Biquad 2nd order Butterworth para extraer DC de se√±al AC e√≥lica
- `readAllSensors()` lee todos los ADCs
- struct SensorData con todos los valores

**relays.h** - Rel√©s:
- `setRelaySolar(bool)`, `setRelayEolica(bool)`, etc
- `aplicarEstrategia()` - L√≥gica autom√°tica de priorizaci√≥n
- Protecci√≥n: no conectar e√≥lica con freno activo

### **Loop principal (simplificado):**
```cpp
void loop() {
  readAllSensors();           // Leer ADCs
  sendStage1Telemetry();      // POST a /telemetry
  checkStage1Commands();      // GET /commands
  printStage1UART();          // Serial: 1 l√≠nea compacta
  
  delay(1000);  // 1 segundo entre iteraciones
}
```

### **Salida Serial (formato actual):**
```
[12] POST:200 GET:200 | R:---C | D34:0.000V D36:0.000V D35:0.000V D39:0.000V
```
Donde:
- `[12]` = secuencia
- `POST:200` = telemetr√≠a OK
- `GET:200` = comandos consultados OK (-7 = timeout)
- `R:---C` = Rel√©s (S=Solar, E=E√≥lica, R=Red, C=Carga, -=OFF)
- `D34:0.000V` = GPIO34 voltaje con 3 decimales

**Cuando llega comando:**
```
***************************************
>>> PRENDER RELE EOLICO <<<
***************************************
‚ö° Rel√© E√≥lica: CONECTADO
[13] POST:200 GET:200 | R:-E-C | D34:0.000V...
```

---

## üêç BACKEND - DETALLES T√âCNICOS

### **Stack:**
- FastAPI (Python)
- Uvicorn (ASGI server)
- SQLite (base de datos)
- scikit-learn (ML Random Forest)
- OpenWeatherMap API (datos meteorol√≥gicos)

### **main.py - Estructura:**

#### Variables globales:
```python
command_queue = {}  # {device_id: [commands]}
telemetry = {}      # {device_id: {last_telemetry, last_seen, relays}}
```

#### Endpoint recibir telemetr√≠a:
```python
@app.post("/api/esp32/telemetry")
async def recibir_telemetria_esp32(data: dict):
    device_id = data.get('device_id')
    
    # Guardar telemetr√≠a
    telemetry[device_id] = {
        'v_bat_v': data.get('v_bat_v'),
        'v_wind_v_dc': data.get('v_wind_v_dc'),
        # ...
        'last_seen': datetime.now()
    }
    
    print(f"[TELEM] {device_id} seq={data.get('seq')}")
    return {"status": "received"}
```

#### Endpoint encolar comando:
```python
@app.post("/api/esp32/command/{device_id}")
async def enviar_comando_esp32(device_id: str, command: dict):
    if device_id not in command_queue:
        command_queue[device_id] = []
    
    command_queue[device_id].append({
        'command': command.get('command'),
        'parameter': command.get('parameter'),
        'timestamp': datetime.now().isoformat()
    })
    
    print(f"üì§ Comando encolado: {command}")
    return {"status": "success"}
```

#### Endpoint consultar comandos (ESP polling):
```python
@app.get("/api/esp32/commands/{device_id}")
async def obtener_comandos_esp32(device_id: str):
    commands = command_queue.get(device_id, [])
    command_queue[device_id] = []  # ‚Üê VAC√çA LA COLA (problema si GET -7)
    
    if commands:
        print(f"[CMD] {device_id} ‚Üí Sent: ...")
        return {"status": "CMD", "commands": commands}
    else:
        return {"status": "OK", "commands": []}
```

### **ML (Predicci√≥n):**
- Random Forest Regressor entrenado con hist√≥ricos
- Predice generaci√≥n solar/e√≥lica 24h adelante
- Usa datos de OpenWeatherMap API
- Archivos: `modelo_solar.pkl`, `modelo_eolico.pkl`

### **Otros endpoints (funcionan bien):**
- `/api/dashboard` - Resumen general
- `/api/energy/history` - Hist√≥rico
- `/api/predictions/24h` - Predicciones ML
- `/api/wind/protection/status` - Estado protecci√≥n embalamiento

---

## ‚öõÔ∏è FRONTEND - DETALLES T√âCNICOS

### **Stack:**
- React 18
- React Router
- Axios (HTTP client)
- Recharts (gr√°ficos)
- Lucide React (iconos)
- Tailwind CSS

### **Componentes relevantes:**

**ESP32Control.jsx** - Control de rel√©s:
```jsx
const DEVICE_ID = 'ESP32_INVERSOR_001';
const API_BASE = 'http://190.211.201.217:11113';

// Fetch estado cada 2s
useEffect(() => {
  const interval = setInterval(async () => {
    const res = await axios.get(`${API_BASE}/api/esp32/estado/${DEVICE_ID}`);
    setEspData(res.data);
  }, 2000);
  return () => clearInterval(interval);
}, []);

// Enviar comando
const sendCommand = async (command, parameter) => {
  await axios.post(`${API_BASE}/api/esp32/command/${DEVICE_ID}`, {
    command,
    parameter
  });
};
```

**Problemas actuales en frontend:**
- ‚ùå Botones no confirman si comando fue ejecutado
- ‚ùå Estado de rel√©s se actualiza cada 2s (si telemetr√≠a llega)
- ‚ùå Si GET -7, estado queda desactualizado

---

## üìÑ DOCUMENTACI√ìN EXISTENTE

El usuario YA TIENE 4 manuales PDF completos:
- `üìò SISTEMA INVERSOR H√çBRIDO - MANUAL T√âCNICO COMPLETO.pdf`
- `üìò SISTEMA INVERSOR H√çBRIDO - MANUAL T√âCNICO COMPLETO (1).pdf`
- `üìò SISTEMA INVERSOR H√çBRIDO - MANUAL T√âCNICO COMPLETO (2).pdf`
- `üìò SISTEMA INVERSOR H√çBRIDO - MANUAL T√âCNICO COMPLETO (3).pdf`

**Contienen:**
- Arquitectura completa del sistema
- Diagramas de flujo
- Explicaci√≥n de ML
- Protecci√≥n embalamiento
- Estrategia autom√°tica
- Instalaci√≥n paso a paso
- Troubleshooting

---

## üéØ QU√â HAY QUE HACER (ALCANCE)

### ‚úÖ LO QUE YA FUNCIONA (NO TOCAR):
- ‚úÖ Backend FastAPI completo
- ‚úÖ Frontend React completo
- ‚úÖ Firmware compila sin errores
- ‚úÖ ESP conecta WiFi
- ‚úÖ Telemetr√≠a llega cada 1s
- ‚úÖ ML predictions
- ‚úÖ Dashboard completo
- ‚úÖ Scripts .bat funcionan
- ‚úÖ Rel√©s se controlan (cuando GET 200)

### ‚ùå LO QUE HAY QUE ARREGLAR (SOLO ESTO):

#### TAREA 1: Eliminar GET -7
**Opciones:**
1. WebSocket bidireccional (mejor soluci√≥n)
2. Aumentar m√°s el timeout (parcial)
3. Reintentos autom√°ticos en ESP (workaround)
4. Cola persistente en backend (no se borra si GET falla)

#### TAREA 2: Sistema de ACK
**Implementar:**
1. ESP incluye en telemetr√≠a: `last_command_executed`
2. Backend trackea: comandos_pendientes vs comandos_ejecutados
3. `send_esp32_command.bat` espera confirmaci√≥n (polling hasta ver ACK)
4. Frontend muestra "Ejecutando..." ‚Üí "Ejecutado ‚úì"

### üìè ALCANCE M√ÅXIMO: 50 PROMPTS (150 CR√âDITOS)

Cada prompt debe:
- Ser espec√≠fico y accionable
- Modificar SOLO lo necesario
- Mantener todo lo que ya funciona
- Verificar que funciona antes de continuar

---

## üõ†Ô∏è COMANDOS √öTILES

### Iniciar sistema completo:
```cmd
cd X:\PREDICCION DE CLIMA
INICIAR_SISTEMA.bat
```

### Iniciar backend solo:
```cmd
cd X:\PREDICCION DE CLIMA\backend
python main.py
```

### Iniciar frontend solo:
```cmd
cd X:\PREDICCION DE CLIMA\frontend
npm start
```

### Probar rel√©s:
```cmd
cd X:\PREDICCION DE CLIMA
test_reles.bat
```

### Enviar comando individual:
```cmd
send_esp32_command.bat eolica on
send_esp32_command.bat eolica off
```

### Verificar estado ESP:
```cmd
curl http://190.211.201.217:11113/api/esp32/estado/ESP32_INVERSOR_001
```

---

## üîç DEBUGGING

### Ver logs backend:
La consola de Python muestra:
```
[TELEM] ESP32_INVERSOR_001 seq=123 ...
üì§ Comando encolado: ...
[CMD] ESP32_INVERSOR_001 ‚Üí Sent: eolica(on)
```

### Ver logs ESP (Serial Monitor 115200):
```
[12] POST:200 GET:200 | R:---C | D34:0.000V...
***************************************
>>> PRENDER RELE EOLICO <<<
***************************************
```

### Ver logs frontend (consola navegador F12):
```
Error loading ESP32 devices: Network Error
```

---

## üìä M√âTRICAS ACTUALES

- **Telemetr√≠a**: 1 mensaje/segundo ‚úÖ
- **Latencia comando** (cuando funciona): < 2 segundos ‚úÖ
- **P√©rdida comandos**: ~83% (5 de 6 se pierden por GET -7) ‚ùå
- **GET -7 frecuencia**: ~50% de los requests ‚ùå
- **Frontend actualizaci√≥n**: 2 segundos ‚úÖ
- **Uptime ESP**: > 24 horas ‚úÖ

---

## üéì CONCEPTOS CLAVE

### HTTP Polling (actual):
- ESP pregunta cada 1s si hay comandos
- Simple, pero pierde comandos si GET falla
- No es tiempo real

### WebSocket (ideal):
- Backend empuja comandos al ESP
- Bidireccional
- Tiempo real
- Requiere cambiar firmware y backend

### Sistema de ACK:
- ESP confirma comando ejecutado
- Backend sabe si lleg√≥ o no
- Frontend puede mostrar estado real

---

## ‚ö†Ô∏è RESTRICCIONES

1. **NO CAMBIAR** la arquitectura general (ESP32 + Backend + Frontend)
2. **NO ELIMINAR** funcionalidades que ya funcionan (ML, protecci√≥n, etc)
3. **MANTENER** los puertos 11113 y 11112
4. **MANTENER** la estructura de archivos
5. **PRIORIZAR** soluciones simples sobre complejas

---

## üìû SI ALGO NO EST√Å CLARO

Preguntar al usuario:
- ¬øQu√© componente espec√≠fico falla?
- ¬øQu√© dice el Serial Monitor del ESP?
- ¬øQu√© dice la consola del backend?
- ¬øQu√© errores muestra el frontend?

NUNCA asumir. SIEMPRE verificar.

---

## üéØ OBJETIVO FINAL

**Sistema 100% funcional donde:**
- ‚úÖ Comandos llegan SIEMPRE (GET 200 siempre, nunca -7)
- ‚úÖ Usuario sabe SI el comando fue ejecutado (ACK visible)
- ‚úÖ Frontend actualiza estado en tiempo real
- ‚úÖ Todo lo dem√°s sigue funcionando (ML, gr√°ficos, protecci√≥n, etc)

**Tiempo estimado:** 3-4 horas con IA eficiente (50 prompts m√°ximo)

---

FIN DEL CONTEXTO COMPLETO
