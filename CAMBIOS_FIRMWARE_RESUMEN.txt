═══════════════════════════════════════════════════════════
  ✅ CAMBIOS APLICADOS AL FIRMWARE
═══════════════════════════════════════════════════════════

📁 ARCHIVOS MODIFICADOS:

1. sensors.h
   ✅ Agregadas variables RAW al struct SensorData:
      • adc_bat1, adc_bat2, adc_bat3
      • adc_solar, adc_eolica, adc_consumo
      • adc_ldr
   
   ✅ Modificadas funciones para guardar valores RAW:
      • leerVoltaje() → guarda valor raw
      • leerCorriente() → guarda valor raw
      • leerIrradiancia() → guarda valor raw
   
   ✅ readAllSensors() actualizada:
      • Ahora guarda TODOS los valores RAW
      • Pasa punteros a las funciones de lectura

2. http_client.h
   ✅ Agregado bloque raw_adc en sendTelemetry():
      • Envía 7 ADCs con valores 0-3.3V
      • Envía valores RAW (0-4095)
      • Convierte con fórmula: (raw * 3.3) / 4095.0

═══════════════════════════════════════════════════════════
  📊 DATOS QUE AHORA SE ENVÍAN:
═══════════════════════════════════════════════════════════

JSON de telemetría incluye nuevo objeto "raw_adc":

{
  "device_id": "ESP32_INVERSOR_001",
  "voltaje_promedio": 59.99,
  "soc": 100,
  ...
  "raw_adc": {
    "adc1_bat1": 2.145,        // Voltaje real 0-3.3V
    "adc1_bat1_raw": 2654,     // Valor ADC 0-4095
    "adc2_bat2": 2.145,
    "adc2_bat2_raw": 2654,
    "adc3_bat3": 2.145,
    "adc3_bat3_raw": 2654,
    "adc4_solar": 1.650,
    "adc4_solar_raw": 2048,
    "adc5_wind": 1.650,
    "adc5_wind_raw": 2048,
    "adc6_load": 1.650,
    "adc6_load_raw": 2048,
    "adc7_ldr": 0.825,
    "adc7_ldr_raw": 1024
  }
}

═══════════════════════════════════════════════════════════
  ✅ VALIDACIÓN DE CAMBIOS:
═══════════════════════════════════════════════════════════

CORRECTA CONEXIÓN DE PINES:
✅ GPIO34 → ADC1_CH6 → Batería 1
✅ GPIO35 → ADC1_CH7 → Batería 2
✅ GPIO32 → ADC1_CH4 → Batería 3
✅ GPIO33 → ADC1_CH5 → Corriente Solar
✅ GPIO36 → ADC1_CH0 → Corriente Eólica
✅ GPIO39 → ADC1_CH3 → Corriente Consumo
✅ GPIO25 → ADC2_CH8 → LDR Irradiancia

FUNCIONES MODIFICADAS:
✅ leerVoltaje(pin, *raw_out) → Guarda raw
✅ leerCorriente(pin, *raw_out) → Guarda raw
✅ leerIrradiancia(pin, *raw_out) → Guarda raw
✅ readAllSensors() → Pasa punteros para guardar

JSON TELEMETRÍA:
✅ Crea objeto "raw_adc"
✅ Convierte ADC a voltaje (0-3.3V)
✅ Incluye valor raw (0-4095)
✅ Envía 7 ADCs completos

═══════════════════════════════════════════════════════════
  🚀 PARA SUBIR EL FIRMWARE:
═══════════════════════════════════════════════════════════

1. Abre Arduino IDE

2. Abre el proyecto:
   File → Open → inversor_hibrido.ino

3. Verifica que compile:
   Sketch → Verify/Compile
   
   Deberías ver:
   "Done compiling."
   Sin errores

4. Selecciona puerto:
   Tools → Port → COMx (donde está el ESP32)

5. Sube:
   Sketch → Upload
   
   Espera mensaje:
   "Hard resetting via RTS pin..."

6. Abre Monitor Serie:
   Tools → Serial Monitor
   Baudrate: 115200
   
   Deberías ver:
   ================================================
   ✅ ¡CONEXIÓN EXITOSA CON EL SERVIDOR!
   ================================================
   
   Y cada 1 segundo:
   📤 Telemetría enviada: 200

═══════════════════════════════════════════════════════════
  ⚠️ VERIFICACIÓN POST-UPLOAD:
═══════════════════════════════════════════════════════════

MONITOR SERIE:
✅ WiFi conectado
✅ Servidor: http://190.211.201.217:11112
✅ Telemetría enviada: 200 (cada 1 seg)
✅ Heartbeat OK (cada 1 seg)

FRONTEND:
✅ Ejecuta REINICIO_TOTAL.bat
✅ Abre http://190.211.201.217:11113
✅ Scroll derecha → Ver panel "📊 ADCs RAW"
✅ Valores actualizándose cada 1 seg
✅ Barras moviéndose en tiempo real

VALORES ESPERADOS:
✅ ADC1-3 (baterías): ~2.0-2.5V (si voltaje 48V)
✅ ADC4-6 (corrientes): ~1.65V (offset ACS712)
✅ ADC7 (LDR): Variable según luz (0-3.3V)

═══════════════════════════════════════════════════════════
  🎯 RESUMEN:
═══════════════════════════════════════════════════════════

ARCHIVOS:
✅ sensors.h → Variables RAW agregadas
✅ http_client.h → Envío de RAW implementado

FUNCIONALIDAD:
✅ Lee ADCs y guarda valores RAW
✅ Convierte a voltaje real (0-3.3V)
✅ Envía al servidor cada 1 segundo
✅ Frontend muestra en panel dedicado

PRÓXIMO PASO:
🔥 SUBIR FIRMWARE AL ESP32 🔥
