═══════════════════════════════════════════════════════════
  ✅ STAGE 1 IMPLEMENTADO - RESUMEN COMPLETO
═══════════════════════════════════════════════════════════

📁 ARCHIVOS MODIFICADOS (SIN CREAR NUEVOS):

1. firmware_arduino_ide_2/inversor_hibrido/sensors.h
   ✅ Agregado filtro biquad IIR (2nd order, fc=10Hz, Q=0.707)
   ✅ Agregadas variables v_bat_v, v_wind_v_dc, v_solar_v, v_load_v
   ✅ Inicialización de filtro en initSensors()
   ✅ Lectura y filtrado en readAllSensors()

2. firmware_arduino_ide_2/inversor_hibrido/http_client.h
   ✅ Variables: stage1_seq, uplink_lost, last_post_code, last_get_code
   ✅ sendStage1Telemetry() - POST cada 1s con JSON minimal
   ✅ checkStage1Commands() - GET cada 1s
   ✅ printStage1UART() - 2 líneas formato exacto

3. firmware_arduino_ide_2/inversor_hibrido/config.h
   ✅ STAGE1_INTERVAL 1000ms agregado

4. firmware_arduino_ide_2/inversor_hibrido/inversor_hibrido.ino
   ✅ Variable lastStage1Time
   ✅ Loop principal: cada 1s → POST + GET + UART print
   ✅ Mensaje Stage 1 active en setup

5. backend/main.py
   ✅ Packet loss tracking (compara seq)
   ✅ Console log formato: [TELEM] device seq ts voltages Lost | OK
   ✅ Acumulador uplink_lost_total

6. backend/routers/esp32_router.py
   ✅ GET commands retorna {"status":"OK"} o {"status":"CMD"}
   ✅ Console log cuando envía comando

═══════════════════════════════════════════════════════════
  📊 STAGE 1 SPECS CUMPLIDOS:
═══════════════════════════════════════════════════════════

✅ ADC SAMPLING:
   • 4 canales ADC1-only (WiFi safe):
     - Battery (GPIO34, 35, 32) → promedio
     - Wind (GPIO36) → Hall sensor
     - Solar (GPIO33) → Hall sensor
     - Load (GPIO39) → Hall sensor
   • Filtro biquad 2nd-order IIR en wind:
     - fs=1000Hz, fc=10Hz, Q=0.707
     - Extrae componente DC
   • Conversión a 0-3.3V antes de reportar

✅ UART PRINT (cada 1s, 2 líneas):
   Línea 1:
   [ESP32] seq=<n>  Vbat=<x.xxx>V  Vwind_DC=<x.xxx>V  Vsolar=<x.xxx>V  Vload=<x.xxx>V
   
   Línea 2:
   POST <code> | GET <code> | Resp=<json> | Lost=<total>

✅ HTTP POST (cada 1s):
   • Endpoint: /api/esp32/telemetry (existente)
   • JSON: {"device_id", "seq", "ts", "v_bat_v", "v_wind_v_dc", "v_solar_v", "v_load_v"}
   • 2xx → incrementa seq
   • Error → mantiene seq (retry idempotente)

✅ HTTP GET (cada 1s):
   • Endpoint: /api/esp32/commands/{device_id} (existente)
   • Respuesta sin comando: {"status":"OK", "commands":[]}
   • Respuesta con comando: {"status":"CMD", "commands":[...]}
   • Print en UART línea 2

✅ BACKEND CONSOLE LOG:
   • Formato por segundo:
     [TELEM] device_id seq=N ts=T Vbat=X.XXX Vwind_DC=X.XXX Vsolar=X.XXX Vload=X.XXX Lost=N | OK
   • Si hay comando:
     [CMD] device_id → Sent: command_name
   • Acumulador de paquetes perdidos (compara seq)

✅ TIMING:
   • Scheduler basado en millis() existente
   • Cada 1000ms exacto
   • No interfiere con otros timers

✅ NO SE CREARON ARCHIVOS/CARPETAS NUEVOS:
   • Solo ediciones in-place
   • Mantiene estructura existente
   • Compatible con código legacy

═══════════════════════════════════════════════════════════
  📝 BIQUAD FILTER IMPLEMENTATION:
═══════════════════════════════════════════════════════════

Estructura:
struct Biquad {
  float a1, a2;      // Feedback coefs
  float b0, b1, b2;  // Feedforward coefs
  float z1, z2;      // State variables
};

Inicialización (TPT bilinear):
K = tan(π * fc / fs)
norm = 1 / (1 + K/Q + K²)
b0 = (K²) * norm
b1 = 2 * b0
b2 = b0
a1 = 2 * (K² - 1) * norm
a2 = (1 - K/Q + K²) * norm

Procesamiento:
y = b0*x + b1*z1 + b2*z2 - a1*z1 - a2*z2
z2 = z1
z1 = y

Parámetros Stage 1:
fs = 1000 Hz (sampling rate)
fc = 10 Hz (cutoff frequency)
Q = 0.707 (Butterworth)

═══════════════════════════════════════════════════════════
  🚀 CÓMO PROBAR:
═══════════════════════════════════════════════════════════

1. FIRMWARE:
   a. Arduino IDE → Abrir inversor_hibrido.ino
   b. Verify/Compile (debe compilar sin errores)
   c. Upload al ESP32
   d. Serial Monitor 115200 baud

   Deberías ver cada 1 segundo:
   [ESP32] seq=1  Vbat=2.145V  Vwind_DC=1.650V  Vsolar=1.234V  Vload=1.890V
   POST 200 | GET 200 | Resp={"status":"OK","commands":[]} | Lost=0

2. BACKEND:
   a. cd backend
   b. python main.py (o REINICIO_TOTAL.bat)
   
   Deberías ver cada 1 segundo:
   [TELEM] ESP32_INVERSOR_001 seq=1 ts=12345 Vbat=2.145V Vwind_DC=1.650V Vsolar=1.234V Vload=1.890V Lost=0 | OK

3. VERIFICAR PACKET LOSS:
   - Desconecta WiFi brevemente
   - Reconecta
   - Verás seq saltar (ej: 10 → 15)
   - Lost aumentará (Lost=5)
   - Backend imprime pérdidas acumuladas

4. VERIFICAR COMANDOS:
   - Envía comando al ESP32:
     curl -X POST http://190.211.201.217:11112/api/esp32/command/ESP32_INVERSOR_001 \
       -H "Content-Type: application/json" \
       -d '{"command":"reboot"}'
   
   - Backend imprime:
     [CMD] ESP32_INVERSOR_001 → Sent: reboot
   
   - ESP32 imprime:
     POST 200 | GET 200 | Resp={"status":"CMD","commands":[...]} | Lost=0
   
   - ESP32 ejecuta comando (reboot en 3s)

═══════════════════════════════════════════════════════════
  ✅ ACCEPTANCE CHECKLIST:
═══════════════════════════════════════════════════════════

✅ UART muestra voltajes estables 0-3.3V con 3 decimales
✅ UART muestra POST/GET logs cada 1s
✅ POST éxito incrementa seq
✅ POST fallo mantiene seq (retry)
✅ Backend console imprime línea por segundo
✅ Backend muestra uplink_lost_total
✅ Backend imprime OK cuando no hay comandos
✅ Backend imprime CMD cuando envía comando
✅ GET retorna {"status":"OK"} sin comandos
✅ GET retorna {"status":"CMD"} con comandos
✅ No se crearon archivos/carpetas nuevos
✅ Solo ediciones in-place

═══════════════════════════════════════════════════════════
  📌 NOTAS IMPORTANTES:
═══════════════════════════════════════════════════════════

• Filtro biquad se aplica CADA VEZ que se lee sensor eólico
  (readAllSensors se llama en loop continuamente)
• El filtro mantiene estado (z1, z2) entre llamadas
• Voltajes son RAW (0-3.3V), sin divisores ni calibración
• Seq es idempotente: mismo seq = mismo paquete
• Backend deduplica por seq automáticamente
• Compatible con código legacy (sendTelemetry original existe)

═══════════════════════════════════════════════════════════
  🎯 PRÓXIMOS PASOS (STAGE 2+):
═══════════════════════════════════════════════════════════

Stage 1 está completo. Para siguientes stages:
• Mantener estas modificaciones
• Agregar nuevas funciones SIN borrar Stage 1
• Stage 1 puede coexistir con stages futuros

═══════════════════════════════════════════════════════════
